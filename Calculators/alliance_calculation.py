import scipy.stats as stats

from DataModels.alliance import Alliance


class AllianceCalculation:
    def __init__(self, alliance, firebase):

        # Solves cyclical dependency
        from .team_calculation import TeamCalculation

        self.alliance = alliance
        self.teams = []
        for team in self.alliance.teams:
            self.teams.append(TeamCalculation(team))
        self.firebase = firebase

    def predicted_score(self, elimination=False):
        '''
            Predicted Score

            pScore = ∑_(T in A) auto_ability(T)
        '''
        p_score = 0.0
        for team in self.teams:
            p_score += team.auto_ability()
        return p_score

    def std_predicted_score(self, elimination=False):
        '''
            Standard Deviation of Predicted Score

            std_pScore = sqrt(∑_(T in A) std_autoAbility(T)^2)
        '''
        std_p_score = 0.0
        for team in self.teams:
            std_p_score += team.std_auto_ability() ** 2
        std_p_score = std_p_score ** 0.5
        return std_p_score

    def win_probability_over(self, o):
        '''
            Win Probability

            In order to determine the win probability of alliance A facing alliance O, Welch's
            t-test (https://en.wikipedia.org/wiki/Welch%27s_t-test). This test is expressed
            using the formula

                t = (X_bar_1 + X_bar_2) / sqrt(s_1^2 / N_1 + s_2^2 / N_2)

                - X_bar_1 is the mean of the first sample
                - s_1 is the standard deviation of the first sample
                - N_1 is the size of the first sample

                - X_bar_2 is the mean of the second sample
                - s_2 is the standard deviation of the second sample
                - N_2 is the size of the second sample

            This t is then converted to a win probability using the cumulative distribution
            function (https://en.wikipedia.org/wiki/Cumulative_distribution_function) for a
            t-distribution T(t|v).

            In this case X_bar_1 is the predicted score for alliance A, s_1 is the standard
            deviation of the predicted score for alliance A, and N_1 is the average number of
            completed matches for each of the teams on alliance A.

                wC(A,O) = T(t|v)

            t is the t-value generated by the Welch's test and v is the degrees of freedom
            approximated by the Welch-Satterthwaite equation
            (https://en.wikipedia.org/wiki/WelchSatterthwaite_equation)

                v ≈ (s_1^2 / N_1 + s_2^2 / N_2)^2 / (s_1^4 / (N_1^2 * v_1) + s_2^4 / (N_2^2 * v_2))

            where v_1 = N_1 - 1 (the degrees of freedom for the first variance) and v_2 = N_2 -1
        '''
        if isinstance(o, Alliance):
            return self.win_probability_over(AllianceCalculation(o))
        else:
            s_1 = self.std_predicted_score()
            s_2 = o.std_predicted_score()
            N_1 = self.sample_size()
            N_2 = o.sample_size()

            t = self.calc.welchs_test(self.predicted_score, o.predicted_score(), s_1, s_2, N_1, N_2)

            v = self.calc.dof(s_1, s_2, N_1, N_2)
            win_chance = stats.t.cdf(t, v)
            return win_chance

    def sample_size(self):
        average = 0.0
        for team in self.teams:
            average += team.num_completed_matches()
        average /= len(self.teams)
        return average
