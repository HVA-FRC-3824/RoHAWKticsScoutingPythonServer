import scipy.stats as stats

from data_models.alliance import Alliance
from firebase_com import FirebaseCom
from calculators.calculator import Calculator


class AllianceCalculator:
    '''Makes calculation about an alliance

    Args:
        alliance (list): list of :class:`Team` objects that make up the :class:`alliance`
    '''
    def __init__(self, alliance):

        # Solves cyclical dependency
        from .team_calculation import TeamCalculator

        self.alliance = alliance
        self.teams = []
        for team in self.alliance.teams:
            self.teams.append(TeamCalculator(team))
        self.firebase = FirebaseCom()

    def predicted_score(self, elimination=False):
        '''Predicted Score

        .. math:: predicted\_score = \sum_{T \in A} auto\_ability(T)
        '''
        p_score = 0.0
        for team in self.teams:
            p_score += team.auto_ability()
        return p_score

    def std_predicted_score(self, elimination=False):
        '''Standard Deviation of Predicted Score

        .. math:: std\_predicted\_score = \sqrt{\sum_{T \in A} std\_auto\_ability(T)^2}
        '''
        std_p_score = 0.0
        for team in self.teams:
            std_p_score += team.std_auto_ability() ** 2
        std_p_score = std_p_score ** 0.5
        return std_p_score

    def win_probability_over(self, o):
        '''Win Probability

        In order to determine the win probability of alliance A facing alliance O, `Welch's
        t-test <https://en.wikipedia.org/wiki/Welch%27s_t-test>`_. This test is expressed
        using the formula

        .. math:: t = \\frac{ \\bar{X_1} + \\bar{X_2} }{ \sqrt{ \\frac{ s_1^2 }{ N_1 } + \\frac{ s_2^2 }{ N_2 } } }

        - :math:`\\bar{X_1}` is the mean of the first sample
        - :math:`s_1` is the standard deviation of the first sample
        - :math:`N_1` is the size of the first sample

        - :math:`\\bar{X_2}` is the mean of the second sample
        - :math:`s_2` is the standard deviation of the second sample
        - :math:`N_2` is the size of the second sample

        This t is then converted to a win probability using the `cumulative distribution
        function <https://en.wikipedia.org/wiki/Cumulative_distribution_function>`_ for a
        t-distribution T(t|v).

        In this case :math:`\\bar{X_1}` is the predicted score for alliance A, :math:`s_1` is the standard
        deviation of the predicted score for alliance A, and :math:`N_1` is the average number of
        completed matches for each of the teams on alliance A.

        win_chance(A,O) = T(t|v)

        t is the t-value generated by the Welch's test and v is the degrees of freedom
        approximated by the `Welch-Satterthwaite equation
        <https://en.wikipedia.org/wiki/WelchSatterthwaite_equation>`_

        .. math::
            v \\approx \\frac{(\\frac{s_1^2}{N_1}+\\frac{s_2^2}{N_2})^2}{\\frac{s_1^4}
            {N_1^2\\cdot v_1}+\\frac{s_2^4}{N_2^2\\cdot v_2}}

        where :math:`v_1 = N_1 - 1` (the degrees of freedom for the first variance) and :math:`v_2 = N_2 -1`
        '''
        if isinstance(o, Alliance):
            return self.win_probability_over(AllianceCalculator(o))
        else:
            s_1 = self.std_predicted_score()
            s_2 = o.std_predicted_score()
            N_1 = self.sample_size()
            N_2 = o.sample_size()

            t = Calculator.welchs_test(self.predicted_score, o.predicted_score(), s_1, s_2, N_1, N_2)

            v = Calculator.dof(s_1, s_2, N_1, N_2)
            win_chance = stats.t.cdf(t, v)
            return win_chance

    def sample_size(self):
        '''Returns the average number of completed matches for each of the teams on alliance A'''
        average = 0.0
        for team in self.teams:
            average += team.num_completed_matches()
        average /= len(self.teams)
        return average
